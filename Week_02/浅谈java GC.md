# 浅谈java GC

java自出生始就与GC完全息息相关。GC既是最受欢迎的一种机制，而GC带来的STW也是最容易受到非java开发人员攻击的一个不能避开的点。所谓GC就是一座墙，墙里的人想出去，墙外的人想进来。

首先来讨论一个原则的问题，那就是为什么GC需要STW：
说到底是因为GC不是一个原子操作的问题，比如说GC线程和业务线程并行执行，然后GC线程找到了一个垃圾，此时这个垃圾的定义是不可达的对象，也就是说从所有的GC root出发都找不到这个对象。但是有一个问题，GC线程肯定没办法直接就知道是否所有的GC Root都无法到达这个对象，也就是必须一个一个Root试，如果我在试第一个GC Root的时候发现这个GC Root没办法到达这个对象，然后我就去访问第二个GC Root了，然后发现也不行，但是此时第一个GC Root可能就有路径能够到达那个对象了，所以如果不STW就没办法解决这些遍历标记的问题。

也就是说STW是没办法避免的，但是就算STW没办法避免，也不意味着我们就什么都不能做了。

### 1. GC发展历史

1.1 java出生就带有GC，此时的GC是SerialGC，在年轻代单线程去复制(Serial New)，老年代单线程标记清理(Serial Old)，整个过程STW。

1.2 为了解决单线程收集的问题，在jdk1.4引入了Parallel GC，在年轻代多线程复制(Parallel Scavenge)，老年代单线程标记清理(Serial Old)，整个过程STW。

1.3 因为STW的备受诟病，开发者想要一个能提供业务并行可配置的GC方式，所以在jdk1.4的后期(也可以认为是jdk1.5时期)，引入了CMS(ConcMarkSweep)来进行对老年代的收集，而在年轻代则为了配合CMS开发了ParNew收集方式，CMS是一个里程碑式的GC，因为是第一个与业务并行的GC，虽然仍然有STW，但是已经大大减少了(只有大概200ms)；但是由于CMS的BUG太多，导致没有非常多的应用，引起碎片过多之后甚至需要Serial OldGC来收集，此时的GC效率大大降低。

1.4  JDK1.6之后将ParallelGC的老年代的Serial OldGC方式改成了Parallel OldGC方式收集。自此，JDK1.7到1.8都是默认的此种GC方式。

1.5 JDK1.7正式引入了G1(1.6高版本已经有了)，G1可以认为是CMS的升级版本，目的和CMS一脉相承，也是为了打造一个与业务并行可配置的GC方式。自此，CMS完成了历史使命，于JDK1.9被建议废弃。JDK9到11的默认gc都是G1。



### 2. GC描述

不同GC开启方式如下：

+ -XX:+UseSerialGC 年轻代和老年代都用串行收集器

+ -XX:+UseParNewGC 年轻代使用ParNew，老年代使用 Serial Old

+ -XX:+UseParallelGC 年轻代使用Paraller Scavenge，老年代使用Serial Old

+ -XX:+UseParallelOldGC 新生代Paraller Scavenge，老年代使用Paraller Old

+ -XX:+UseConcMarkSweepGC，年轻代使用ParNew，老年代的用CMS (极端情况Serial Old)

+ -XX:+UseG1GC 使用G1垃圾回收器(极端情况Serial Old)

+ -XX:+UseZGC 使用ZGC垃圾回收器

不同的GC虽然理念不同导致设计方向也不同，但是不同GC也就意味着不同的业务场景，不能意味追求新技术而因为新技术放弃了业务使用场景。基于1.8的环境做了GCLogAnalysis的测试，发现在1G的内存的情况下，效果最好的居然是CMS，这让我非常惊奇，虽然这个例子可能不算非常可信，但是起码证明在不同的业务场景下，唯有实践才能选择自己最适合的GC方式。

网上查到的不同GC大概适合使用的内存范围：

Serial：几十兆
PS：上百兆 ~ 4G
CMS：4G ~ 10G
G1：10G~上百G
ZGC： 4T - 16T（JDK13）

## 3. GC的选择

GC的选择主要是实践，但是也不是盲目的实践，而是有一定方向去实践。

主要还是要观察自己的业务场景

1. 对于计算密集型的应用，更应该注意吞吐量，此时时延就可以相对位置放低。主要思路应该往PS方向去看。如果PS无法满足在尝试G1或者ZGC。
2. OLTP方式的系统则必须注意时延的影响，为了让用户有最优的体验，建议直接使用ZGC或者G1。
3. GC方式不一定满足所有的平台，甚至在不同的平台上可能会有不同的表现，比如ZGC就没有Window版本。所以不同的版本需要不同的测试。
4. 可能还有公司的历史问题需要关注（比如接收的系统是基于jdk1.6的，那就不用想那些新的GC方式了）。此时就应该在被局限的范围内按前述的方式去选取。







